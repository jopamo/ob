#!/usr/bin/env python3
"""
openbox-xdg-autostart
Runs programs defined by the XDG autostart specification.

Originally written 2008-01-28 by Dana Jansens for Openbox.
Updated for Python 3.13+ (prints, error handling, style) 2025-06-17.

Licence: GPL-2.0-or-later
"""

from __future__ import annotations

import glob
import os
import subprocess
import sys
from pathlib import Path
from typing import List, Sequence

try:
    from xdg import BaseDirectory
    from xdg.DesktopEntry import DesktopEntry
    from xdg.Exceptions import ParsingError
except ImportError as exc:  # pragma: no cover
    sys.stderr.write(
        "ERROR: openbox-xdg-autostart requires the PyXDG package "
        "(python-xdg / pyxdg) to be installed\n"
    )
    sys.exit(1)

ME = "openbox-xdg-autostart"
VERSION = "1.2"


# ────────────────────────────── helpers ──────────────────────────────


def _is_exec_file(path: str | os.PathLike[str]) -> bool:
    """Return True if *path* exists and is executable."""
    return os.access(path, os.X_OK)


def _find_in_path(filename: str, search_path: str, match) -> str | None:
    """Locate *filename* in *search_path* using *match* as the test."""
    if not filename:
        return None

    if os.path.isabs(filename):
        return filename if match(filename) else None

    for directory in search_path.split(os.pathsep):
        if directory:
            candidate = os.path.join(directory, filename)
            if match(candidate):
                return candidate
    return None


def _alert(msg: str, *, info: bool = False) -> None:
    """Pretty-print diagnostic information."""
    prefix = "\t " if info else "\t*"
    print(f"{prefix} {msg}")


# ────────────────────────────── core class ───────────────────────────


class AutostartFile:
    """A single *.desktop* autostart file."""

    def __init__(self, path: str | os.PathLike[str]) -> None:
        self.path = str(path)
        self.filename = os.path.basename(self.path)
        self.de = DesktopEntry(self.path)

    # Make files with the same base-name compare equal
    def __eq__(self, other) -> bool:  # type: ignore[override]
        return isinstance(other, AutostartFile) and self.filename == other.filename

    # For `print(autofile)`
    def __str__(self) -> str:  # pragma: no cover
        return f"{self.path} : {self.de.getName()}"

    # ───── filtering helpers ─────

    def _show_in_environment(self, envs: Sequence[str], *, verbose: bool = False) -> bool:
        """Return True if this entry should be shown/run for *envs*."""
        default = not self.de.getOnlyShowIn()
        noshow = any(env in self.de.getNotShowIn() for env in envs)
        force = any(env in self.de.getOnlyShowIn() for env in envs)

        if verbose:
            if not default and not force:
                _alert(
                    f"Excluded by: OnlyShowIn ({', '.join(self.de.getOnlyShowIn())})"
                )
            if default and noshow and not force:
                _alert(
                    f"Excluded by: NotShowIn ({', '.join(self.de.getNotShowIn())})"
                )
        return (default and not noshow) or force

    def _should_run(self, envs: Sequence[str], *, verbose: bool = False) -> bool:
        """Return True if the entry passes all filters."""
        if not self.de.getExec():
            if verbose:
                _alert("Excluded by: Missing Exec field")
            return False

        if self.de.getHidden():
            if verbose:
                _alert("Excluded by: Hidden")
            return False

        if tryexec := self.de.getTryExec():
            if not _find_in_path(tryexec, os.getenv("PATH", ""), _is_exec_file):
                if verbose:
                    _alert(f"Excluded by: TryExec ({tryexec})")
                return False

        return self._show_in_environment(envs, verbose=verbose)

    # ───── public actions ─────

    def display(self, envs: Sequence[str]) -> None:
        """Print diagnostic info about whether this entry would run."""
        mark = "[*]" if self._should_run(envs) else "[ ]"
        print(f"{mark} {self.de.getName()}")
        _alert(f"File: {self.path}", info=True)
        if (exec_cmd := self.de.getExec()) is not None:
            _alert(f"Executes: {exec_cmd}", info=True)
        self._should_run(envs, verbose=True)
        print()  # blank line

    def run(self, envs: Sequence[str]) -> None:
        """Spawn the autostart entry if it passes all filters."""
        if not self._should_run(envs):
            return

        exec_cmd = self.de.getExec()
        if exec_cmd is None:
            return

        # Change working directory if Path= is set
        cwd = Path.cwd()
        try:
            if (path := self.de.getPath()) is not None:
                os.chdir(path)

            # Use sh -c "exec <command>" so .desktop Exec lines are interpreted
            subprocess.Popen(
                ["/bin/sh", "-c", f"exec {exec_cmd}"],
                close_fds=True,
            )
        finally:
            os.chdir(cwd)  # always return


# ────────────────────────────── CLI ──────────────────────────────────


def show_help() -> None:
    """Print command-line usage."""
    print(
        f"""Usage: {ME} [OPTION]... [ENVIRONMENT]...

Run programs specified by XDG autostart .desktop files.

Options
  --list        List which files would be run and the reason for exclusions
  --help        Show this help and exit
  --version     Show version information and exit

If no ENVIRONMENT is given, only files not limited to specific environments
are executed.  Valid environments include: GNOME, KDE, ROX, XFCE, Old.
"""
    )


def show_version() -> None:  # pragma: no cover
    print(f"{ME} {VERSION}\nCopyright (c) 2008 Dana Jansens")


def main(argv: Sequence[str] | None = None) -> int:
    """Program entry-point.  Returns exit status."""
    if argv is None:
        argv = sys.argv

    if "--help" in argv:
        show_help()
        return 0
    if "--version" in argv:
        show_version()
        return 0

    list_mode = "--list" in argv
    envs: List[str] = [arg for arg in argv[1:] if not arg.startswith("--")]

    # Gather autostart files
    autostart_dirs = BaseDirectory.load_config_paths("autostart")
    files: List[AutostartFile] = []
    for directory in autostart_dirs:
        for path in glob.glob(os.path.join(directory, "*.desktop")):
            try:
                autostart_file = AutostartFile(path)
            except ParsingError:
                print(f"Invalid .desktop file: {path}", file=sys.stderr)
                continue
            if autostart_file not in files:
                files.append(autostart_file)

    # Act
    for autostart_file in files:
        if list_mode:
            autostart_file.display(envs)
        else:
            autostart_file.run(envs)

    return 0


if __name__ == "__main__":  # pragma: no cover
    sys.exit(main())
